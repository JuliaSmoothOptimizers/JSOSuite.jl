<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · JSOSuite.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="JSOSuite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">JSOSuite.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../nls/">Nonlinear Least Squares</a></li><li><a class="tocitem" href="../qp/">Quadratic models with linear constraints</a></li><li><a class="tocitem" href="../benchmark/">Benchmarking</a></li><li><a class="tocitem" href="../speed-up/">Speed up Solvers Tips</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/JSOSuite.jl/blob/main/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>​</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><p>​</p><ul><li><a href="#Reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><p>​</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><p>​</p><ul><li><a href="#JSOSuite.solvers"><code>JSOSuite.solvers</code></a></li><li><a href="#JSOSuite.feasible_point"><code>JSOSuite.feasible_point</code></a></li><li><a href="#JSOSuite.generic"><code>JSOSuite.generic</code></a></li><li><a href="#JSOSuite.select_solvers-Union{Tuple{NLPModels.AbstractNLPModel{T, S}}, Tuple{S}, Tuple{T}, Tuple{NLPModels.AbstractNLPModel{T, S}, Any}, Tuple{NLPModels.AbstractNLPModel{T, S}, Any, Integer}} where {T, S}"><code>JSOSuite.select_solvers</code></a></li><li><a href="#JSOSuite.solve"><code>JSOSuite.solve</code></a></li><li><a href="#SolverBenchmark.bmark_solvers"><code>SolverBenchmark.bmark_solvers</code></a></li><li><a href="#SolverCore.solve!-Tuple{Any, Vararg{Any}}"><code>SolverCore.solve!</code></a></li></ul><p>​</p><article class="docstring"><header><a class="docstring-binding" id="JSOSuite.solvers" href="#JSOSuite.solvers"><code>JSOSuite.solvers</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">solvers</code></pre><p>DataFrame with the JSO-compliant solvers and their properties.</p><p>For each solver, the following are available:</p><ul><li><code>name::String</code>: name of the solver;</li><li><code>name_solver::Symbol</code>: name of the solver structure for in-place solve, <code>:not_implemented</code> if not implemented;</li><li><code>name_pkg::String</code>: name of the package implementing this solver or its NLPModel wrapper;</li><li><code>solve_function::Symbol</code>: name of the function;</li><li><code>is_available::Bool</code>: <code>true</code> if the solver is available;</li><li><code>bounds::Bool</code>: <code>true</code> if the solver can handle bound constraints;</li><li><code>equalities::Bool</code>: <code>true</code> if the solver can handle equality constraints;</li><li><code>inequalities::Bool</code>: <code>true</code> if the solver can handle inequality constraints;</li><li><code>specialized_nls::Bool</code>: <code>true</code> if the solver has a specialized variant for nonlinear least squares;</li><li><code>can_solve_nlp::Bool</code>: <code>true</code> if the solver can solve general problems. Some may only solve nonlinear least squares;</li><li><code>nonlinear_obj::Bool</code>: <code>true</code> if the solver can handle nonlinear objective;</li><li><code>nonlinear_con::Bool</code>: <code>true</code> if the solver can handle nonlinear constraints;</li><li><code>double_precision_only::Bool</code>: <code>true</code> if the solver only handles double precision (<code>Float64</code>);</li><li><code>highest_derivative::Int</code>: order of the highest derivative used by the algorithm.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/JSOSuite.jl/blob/bbe4a4c9e2b25094475d9b87e890bc3bc080b0de/src/JSOSuite.jl#L17-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JSOSuite.feasible_point" href="#JSOSuite.feasible_point"><code>JSOSuite.feasible_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stats = feasible_point(nlp::Union{AbstractNLPModel, JuMP.Model}; kwargs...)
stats = feasible_point(nlp::Union{AbstractNLPModel, JuMP.Model}, solver_name::Symbol; kwargs...)</code></pre><p>Compute a feasible point of the optimization problem <code>nlp</code>. The signature is the same as the function <a href="#JSOSuite.solve"><code>solve</code></a>.</p><p><strong>Output</strong></p><p>The value returned is a <code>GenericExecutionStats</code>, see <code>SolverCore.jl</code>, where the <code>status</code>, <code>solution</code>, <code>primal_residual</code>, <code>iter</code> and <code>time</code> are filled-in.</p><pre><code class="language-julia hljs">using ADNLPModels, JSOSuite
c(x) = [10 * (x[2] - x[1]^2); x[1] - 1]
b = zeros(2)
nlp = ADNLPModel(x -&gt; 0.0, [-1.2; 1.0], c, b, b)
stats = feasible_point(nlp, verbose = 0)
stats</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/JSOSuite.jl/blob/bbe4a4c9e2b25094475d9b87e890bc3bc080b0de/src/JSOSuite.jl#L414-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JSOSuite.generic" href="#JSOSuite.generic"><code>JSOSuite.generic</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Checker whether solvers are Generic only</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/JSOSuite.jl/blob/bbe4a4c9e2b25094475d9b87e890bc3bc080b0de/src/selection.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JSOSuite.select_solvers-Union{Tuple{NLPModels.AbstractNLPModel{T, S}}, Tuple{S}, Tuple{T}, Tuple{NLPModels.AbstractNLPModel{T, S}, Any}, Tuple{NLPModels.AbstractNLPModel{T, S}, Any, Integer}} where {T, S}" href="#JSOSuite.select_solvers-Union{Tuple{NLPModels.AbstractNLPModel{T, S}}, Tuple{S}, Tuple{T}, Tuple{NLPModels.AbstractNLPModel{T, S}, Any}, Tuple{NLPModels.AbstractNLPModel{T, S}, Any, Integer}} where {T, S}"><code>JSOSuite.select_solvers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select_solvers(nlp::AbstractNLPModel, verbose = 1, highest_derivative_available::Integer = 2)</code></pre><p>Narrow the list of solvers to solve <code>nlp</code> problem using <code>highest_derivative_available</code>.</p><p>This function checks whether the model has:</p><ul><li>linear or nonlinear constraints;</li><li>unconstrained, bound constraints, equality constraints, inequality constraints;</li><li>nonlinear or quadratic objective.</li></ul><p>A linear or quadratic objective is detected if the type of <code>nlp</code> is a <code>QuadraticModel</code> or an <code>LLSModel</code>. The selection between a general optimization problem and a nonlinear least squares is done in <a href="#JSOSuite.solve"><code>solve</code></a>.</p><p>If no solvers were selected, consider setting <code>verbose</code> to <code>true</code> to see what went wrong.</p><p><strong>Output</strong></p><ul><li><code>selected_solvers::DataFrame</code>: A subset of <a href="#JSOSuite.solvers"><code>solvers</code></a> adapted to the problem <code>nlp</code>.</li></ul><p>See also <a href="#JSOSuite.solve"><code>solve</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using ADNLPModels, JSOSuite
nlp = ADNLPModel(x -&gt; 100 * (x[2] - x[1]^2)^2 + (x[1] - 1)^2, [-1.2; 1.0])
selected_solvers = JSOSuite.select_solvers(nlp)
print(selected_solvers[!, :name])</code></pre><pre><code class="language-julia hljs">using ADNLPModels, JSOSuite
nlp = ADNLSModel(x -&gt; [10 * (x[2] - x[1]^2), (x[1] - 1)], [-1.2; 1.0], 2)
selected_solvers = JSOSuite.select_solvers(nlp)
print(selected_solvers[!, :name])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/JSOSuite.jl/blob/bbe4a4c9e2b25094475d9b87e890bc3bc080b0de/src/selection.jl#L1-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JSOSuite.solve" href="#JSOSuite.solve"><code>JSOSuite.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stats = solve(nlp::Union{AbstractNLPModel, JuMP.Model}; kwargs...)</code></pre><p>Compute a local minimum of the optimization problem <code>nlp</code>.</p><pre><code class="nohighlight hljs">stats = solve(f::Function, x0::AbstractVector, args...; kwargs...)
stats = solve(F::Function, x0::AbstractVector, nequ::Integer, args...; kwargs...)</code></pre><p>Define an NLPModel using <a href="https://juliasmoothoptimizers.github.io/ADNLPModels.jl/stable/"><code>ADNLPModel</code></a>.</p><pre><code class="nohighlight hljs">stats = solve(c, H, c0 = c0, x0 = x0, name = name; kwargs...)
stats = solve(c, H, lvar, uvar, c0 = c0, x0 = x0, name = name; kwargs...)
stats = solve(c, H, A, lcon, ucon, c0 = c0, x0 = x0, name = name; kwargs...)
stats = solve(c, H, lvar, uvar, A, lcon, ucon, c0 = c0, x0 = x0, name = name; kwargs...)</code></pre><p>Define a QuadraticModel using <a href="https://juliasmoothoptimizers.github.io/QuadraticModels.jl/stable/"><code>QuadraticModel</code></a>.</p><p>The solver can be chosen as follows.</p><pre><code class="nohighlight hljs">stats = solve(solver_name::String, args...; kwargs...)</code></pre><p><code>JuMP.Model</code> are converted in NLPModels via NLPModelsJuMP.jl.</p><p>If your optimization problem has a quadratic or linear objective and linear constraints consider using QuadraticModels.jl or LLSModels.jl for the model definition.</p><p><strong>Keyword Arguments</strong></p><p>All the keyword arguments are passed to the selected solver. Keywords available for all the solvers are given below:</p><ul><li><code>atol</code>: absolute tolerance;</li><li><code>rtol</code>: relative tolerance;</li><li><code>max_time</code>: maximum number of seconds;</li><li><code>max_iter</code>: maximum number of iterations;</li><li><code>max_eval</code>: maximum number of cons + obj evaluations;</li><li><code>callback = (args...) -&gt; nothing</code>: callback called at each iteration;</li><li><code>verbose::Int = 0</code>: if &gt; 0, display iteration details every <code>verbose</code> iteration.</li></ul><p>The following are specific to nonlinear least squares:</p><ul><li><code>Fatol::T = √eps(T)</code>: absolute tolerance on the residual;</li><li><code>Frtol::T = eps(T)</code>: relative tolerance on the residual, the algorithm stops when ‖F(xᵏ)‖ ≤ Fatol + Frtol * ‖F(x⁰)‖.</li></ul><p>Further possible options are documented in each solver&#39;s documentation.</p><p><strong>Callback</strong></p><p>The callback is called at each iteration. The expected signature of the callback is <code>callback(nlp, solver, stats)</code>, and its output is ignored. Changing any of the input arguments will affect the subsequent iterations. In particular, setting <code>stats.status = :user</code> will stop the algorithm. All relevant information should be available in <code>nlp</code> and <code>solver</code>.</p><p><strong>Output</strong></p><p>The value returned is a <code>GenericExecutionStats</code>, see <code>SolverCore.jl</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using JSOSuite
stats = solve(x -&gt; 100 * (x[2] - x[1]^2)^2 + (x[1] - 1)^2, [-1.2; 1.0], verbose = 0)
stats</code></pre><p>The list of available solver can be obtained using <code>JSOSuite.solvers[!, :name]</code> or see <a href="#JSOSuite.select_solvers-Union{Tuple{NLPModels.AbstractNLPModel{T, S}}, Tuple{S}, Tuple{T}, Tuple{NLPModels.AbstractNLPModel{T, S}, Any}, Tuple{NLPModels.AbstractNLPModel{T, S}, Any, Integer}} where {T, S}"><code>select_solvers</code></a>.</p><pre><code class="language-julia hljs">using JSOSuite
stats = solve(&quot;DCISolver&quot;, x -&gt; 100 * (x[2] - x[1]^2)^2 + (x[1] - 1)^2, [-1.2; 1.0], verbose = 0)
stats</code></pre><pre><code class="language-julia hljs">using JSOSuite
# We solve here a quadratic problem with bound-constraints
c = [1.0; 1.0]
H = [-2.0 0.0; 3.0 4.0]
uvar = [1.0; 1.0]
lvar = [0.0; 0.0]
x0 = [0.5; 0.5]
stats = solve(&quot;TRON&quot;, c, H, lvar, uvar, x0 = x0, name = &quot;bndqp_QP&quot;, verbose = 0)
stats</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/JSOSuite.jl/blob/bbe4a4c9e2b25094475d9b87e890bc3bc080b0de/src/JSOSuite.jl#L183-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolverBenchmark.bmark_solvers" href="#SolverBenchmark.bmark_solvers"><code>SolverBenchmark.bmark_solvers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bmark_solvers(problems, solver_names::Vector{String}; kwargs...)
bmark_solvers(problems, solver_names::Vector{String}, solvers::Dict{Symbol, Function}; kwargs...)</code></pre><p>Wrapper to the function <a href="https://github.com/JuliaSmoothOptimizers/SolverBenchmark.jl/blob/main/src/bmark_solvers.jl">SolverBenchmark.bmark_solvers</a>.</p><p><strong>Arguments</strong></p><ul><li><code>problems</code>: The set of problems to pass to the solver, as an iterable of<code>AbstractNLPModel</code>;</li><li><code>solver_names::Vector{String}</code>: The names of the benchmarked solvers. They should be valid <code>JSOSuite</code> names, see <code>JSOSuite.solvers.name</code> for a list;</li><li><code>solvers::solvers::Dict{Symbol, Function}</code>: A dictionary of additional solvers to benchmark.</li></ul><p><strong>Output</strong></p><p>A Dict{Symbol, DataFrame} of statistics.</p><p><strong>Keyword Arguments</strong></p><p>The following keywords available are passed to the <code>JSOSuite</code> solvers:</p><ul><li><code>atol</code>: absolute tolerance;</li><li><code>rtol</code>: relative tolerance;</li><li><code>max_time</code>: maximum number of seconds;</li><li><code>max_eval</code>: maximum number of cons + obj evaluations;</li><li><code>verbose::Int = 0</code>: if &gt; 0, display iteration details every <code>verbose</code> iteration.</li></ul><p>All the remaining keyword arguments are passed to the function <code>SolverBenchmark.bmark_solvers</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using ADNLPModels, JSOSuite
nlps = (
  ADNLPModel(x -&gt; 100 * (x[2] - x[1]^2)^2 + (x[1] - 1)^2, [-1.2; 1.0]),
  ADNLPModel(x -&gt; 4 * (x[2] - x[1]^2)^2 + (x[1] - 1)^2, [-1.2; 1.0]),
)
names = [&quot;LBFGS&quot;, &quot;TRON&quot;] # see `JSOSuite.solvers.name` for the complete list
stats = bmark_solvers(nlps, names, atol = 1e-3, verbose = 0, colstats = [:name, :nvar, :ncon, :status])
keys(stats)</code></pre><p>The second example shows how to add you own solver to the benchmark.</p><pre><code class="language-julia hljs">using ADNLPModels, JSOSolvers, JSOSuite, Logging
nlps = (
  ADNLPModel(x -&gt; 100 * (x[2] - x[1]^2)^2 + (x[1] - 1)^2, [-1.2; 1.0]),
  ADNLPModel(x -&gt; 4 * (x[2] - x[1]^2)^2 + (x[1] - 1)^2, [-1.2; 1.0]),
)
names = [&quot;LBFGS&quot;, &quot;TRON&quot;] # see `JSOSuite.solvers.name` for the complete list
other_solvers = Dict{Symbol, Function}(
  :test =&gt; nlp -&gt; lbfgs(nlp; mem = 2, atol = 1e-3, verbose = 0),
)
stats = bmark_solvers(nlps, names, other_solvers, atol = 1e-3, verbose = 0, colstats = [:name, :nvar, :ncon, :status])
keys(stats)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/JSOSuite.jl/blob/bbe4a4c9e2b25094475d9b87e890bc3bc080b0de/src/JSOSuite.jl#L302-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolverCore.solve!-Tuple{Any, Vararg{Any}}" href="#SolverCore.solve!-Tuple{Any, Vararg{Any}}"><code>SolverCore.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(solver::AbstractOptimizationSolver, model::Union{AbstractNLPModel, JuMP.Model}; kwargs...)
solve!(solver::AbstractOptimizationSolver, model::Union{AbstractNLPModel, JuMP.Model}, stats; kwargs...)</code></pre><p><code>JSOSuite</code> extension of <code>SolverCore.solve!</code>. The first argument should be of type <code>SolverCore.AbstractOptimizationSolver</code>, see for instance <code>JSOSuite.solvers[!, :name_solver]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/JSOSuite.jl/blob/bbe4a4c9e2b25094475d9b87e890bc3bc080b0de/src/JSOSuite.jl#L283-L289">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../speed-up/">« Speed up Solvers Tips</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 20 July 2023 17:55">Thursday 20 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
